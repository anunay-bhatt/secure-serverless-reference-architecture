# Reference Architecture for a secure Serverless Application

Serverless computing can help organizations reduce the operational overhead while delivering highly scalable and reliable services to the customers in a cost effective manner. But does using these serverless services also reduce the burden of security implementation compared to IaaS or PaaS infrastructures? Simple answer is yes, since with the decrease in the responsibility to maintain servers, the security responsibility also decreases. However, even if these applications are running without a managed server, they still execute code. If this code is written in an insecure manner, it can still be vulnerable to application-level attacks. Also cloud configuration mistakes can still lead to infrastructure-level attacks.

This repo contains a sample Terraform configuration for deploying a secure serverless application on AWS. The referenced sample application is a Vulnerability Management API service which provides API based access to the vulnerability database generated by threat monitoring services like Nessus, Aqua, etc. The customers of VMS are the authenticated clients which GET access to their vulnerabilities and its related metadata. Admin customers like threat monitoring services POST the vulnerability data to the sample app. 

Please note, this is just one of the many ways developers can deploy such an app on AWS. In the article on Medium (--> link here), we do a deeper discussion on the security of a serverless application deployed on public cloud and the many options that developers today have to secure their serverless workloads.

## Application Architecture

AWS serverless resources are used for creating this architecture with API Gateway used for API management, Lambda used as the Logic layer and the persistent layer being DynamoDB. OpenAPI specification is used for creating the two API endpoints - GET and POST with API Gateway. Lambda is used first for authorizing the requests coming in via API Gateway and then for processing the authorized requests. Similarly, DynamoDB is used for storing two kinds of data - one being the metadata to authorize requests and second the vulnerability data itself for the application. 

![](https://github.com/ab-lumos/secure-serverless-reference-architecture/blob/master/Application_Architecture_sample_serverless_app.jpeg)

## Integrated Security Controls
This table provides a summary of the various security controls integrated with this sample application. For a detailed justification of these, refer to the Medium article <link to article here>

Table here with "Security Area" and "Security Control"


<table>
    <thead>
        <tr>
            <th>Security Area</th>
            <th>Security Control</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan=3>IAM</td>
            <td>Authentication for both client and server is enabled via digital certificates using mutual TLS (mTLS)</td>
        </tr>
        <tr>
            <td>Lambda Authorizers are used in API Gateway to validate the Organization Unit (OU) field of the client certificate against the resources that that particular OU is allowed to access. Such a mapping is created in the backend DynamoDB</td>
        </tr>
        <tr>
            <td>Least Privilege - Serverless cloud resources only have the least amount of permissions to perform their task and no more. Ergo, in cases of unwanted abuse of these resources, the blast radius would be minimal.</td>
        </tr>
        <tr>
            <td rowspan=5>Network Security</td>
            <td>API Customers can only access the REST API from specific network locations (ip addresses)</td>
        </tr>
        <tr>
            <td>Encryption in transit with TLS must be enabled on the API endpoint and only secure TLS protocol and cipher version must be used</td>
        </tr> 
        <tr>
            <td>The default API endpoint must be disabled so that the TLS or mTLS controls on the custom domain are not bypassed by using the default domain</td>
        </tr> 
        <tr>
            <td>Serverless cloud backend resources must not be publicly accessible. Configuration mistakes like these can inadvertently expose the backend data of serverless apps</td>
        </tr> 
         <tr>
            <td>For inter-communication between services, if not configured otherwise, the traffic is routed via public Internet which seems rather unnecessary risk as these services are most probability are internal to your design. In such cases and as applicable with each cloud provider, it is advisable to use private endpoints so that traffic to serverless services be kept on cloud service provider's backbone network rather than Internet at large. Endpoint policy must be setup to only network access to a specific resource via the private endpoint</td>
        </tr> 
        <tr>
            <td rowspan=2>Code SecurityÂ Hygiene</td>
            <td>API endpoints must have API throttling limits so that your API is not overwhelmed with too many requests and does not become non-functional.</td>
        </tr>
         <tr>
            <td>Test</td>
        </tr> 
         <tr>
            <td rowspan=2>Data Protection</td>
            <td>Backup of DynamoDB</td>
        </tr>
    </tbody>
</table>

## How to deploy this code in your own environment

### Pre-requisites

1. An AWS account and privileges to deploy the related infrastructure as part of this repo

2. A domain name which you own and which will be used as the main url for the VMS service. Update your domain name in the terraform.tfvars file

3. The API Gateway has mTLS enabled which means clients would need to present their certifcate which would be authentictaed by the server with a trust bundle. For the puposes of this demo, create self-signed certificates for CA, POST Client and GET using the below commands:

Certificate Authority:

        openssl genrsa -aes256 -out ca/ca.key 4096 chmod 400 ca/ca.key
        openssl req -new -x509 -sha256 -days 730 -key ca/ca.key -out ca/ca.crt
        chmod 444 ca/ca.crt

POST Client Certificate:
This certificat is used for creating/adding new vulnerability data to the database

        openssl genrsa -out client/client_post.key 2048

"Make sure that you put an apporpriate OU in the below CSR. This OU would be used for authorization of the client. You will update the same in the terraform.tfvars file variable -- OU_with_POST_authorization"

        openssl req -new -key client/client_post.key -out client/client_post.csr
        openssl x509 -req -days 365 -sha256 -in client/client_post.csr -CA ca.crt -CAkey ca.key -set_serial 2 -out client/client_post.crt

GET Client Certificate:
This certificat is used for viewing vulnerability data from the database

        openssl genrsa -out client/client_get.key 2048

"Make sure that you put an apporpriate OU in the below CSR. This OU would be used for authorization of the client. You will update the same in the terraform.tfvars file variable -- OU_with_GET_authorization"

        openssl req -new -key client/client_get.key -out client/client_get.csr
        openssl x509 -req -days 365 -sha256 -in client/client_get.csr -CA ca.crt -CAkey ca.key -set_serial 2 -out client/client_get.crt

4. Upload your trust bundle which is the public certificate for your root CA at "./trustbundle/ca.pem"

5. Update the OU name for the certificate that will use the POST API in the variable in terraform.tfvars file --> "OU_with_POST_authorization"

6. Update the OU name for the certificate that will be used for the GET API in the variable in terraform.tfvars file --> "OU_with_GET_authorization". Please also mention the Orgs that this partcular OU will have authorization to access. 


### Inputs
Update terraform.tfvars with your input values as necessary:

Table below: 


### Terraform apply
Plan, apply and check results

        terraform plan
        terraform apply

### Outputs
 
Table below: 

### Post deployment instructions

The default endpoint created by API Gateway is disabled as it can bypass mTLS controls. You will be reaching to the API with the custom domain name which you supplied as input to the Terraform. This Terraform code also updates the DNS record for the domain with an alias for the API Gateway endpoint.

1. Using the POST client certificate, you will be successfull with the following curl request: 
curl -v -X POST --cert ./client_post/client_post.crt --key ./client_post/client_post.key "https://serverless.<your_domain_name>/vuln" --header "Content-Type: application/json" --data '{
          "VulnID" : "testID3",
          "Org" : "org1",
          "AssetName" : "lax-psg-g.internal.org.com",
          "DueDate"   : "09-09-2022",
          "PluginId"  : 23234,
          "PluginName" : "Palo Alto confusion ADE-OS Local File Inclusion",
          "Priority"  : "234234234"
}'

2. If you try to use the above POST request with the GET client using the below command, you will receive an access error: 
curl -v -X POST --cert ./client_post/client_get.crt --key ./client_post/client_get.key "https://serverless.<your_domain_name>/vuln" --header "Content-Type: application/json" --data '{
          "VulnID" : "testID3",
          "Org" : "org1",
          "AssetName" : "lax-psg-g.internal.org.com",
          "DueDate"   : "09-09-2022",
          "PluginId"  : 23234,
          "PluginName" : "Palo Alto confusion ADE-OS Local File Inclusion",
          "Priority"  : "234234234"
}'

3. Using the GET client certificate, you will get response for the following curl request: 
curl -v -X GET --cert ./client_get/client_get.crt --key ./client_get/client_get.key "https://serverless.<your_domain_name>/vuln?org=org1"

4. Check for other orgs which are given access to the GET client, you will the access denied error: 
curl -v -X GET --cert ./client_get/client_get.crt --key ./client_get/client_get.key "https://serverless.ab-lumos.link/vuln?org=org5"

